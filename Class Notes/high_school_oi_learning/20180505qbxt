#include<C++>
begin.
字符串：
	存储：
	C语言，字符数组；
	C++，string类；
	最后一位是'\0';
	
	基本操作：
	取长度、把前者链接到后者的后面、在后者中寻找前者、比较长度大小、循环处理时避免重复计算；
	C语言就用函数；
	C++可以用成员函数和运算符；
	
	KMP算法：
	求B在A里面出现了几次；
	暴力匹配，逐位比较；
	F[I]:最大的K，使得A后K位等于B前K位；
	NEXT[I]:最大的K，使得B前K位等于后K位；
	先算NEXT再算F，这是怎么想出来的想法······；
	https://www.cnblogs.com/zhangtianq/p/5839909.html；
	
	trie树：
	共用节点存储多个字符串；
	插入：有对应边就继续，无对应边就新建；
	遍历：在单词末尾加个标记；首先指向根节点，其次若每个字符都存在而且末尾有单词标记则找到；
	性质：要求每个节点的子节点记录的字符不相同；
	查询速度快，空间复杂度小；
		例题：
		给出备选单词，对于按照九键输入法数字给出的单词进行查询；
		把字母转成数字串进行处理；
	用途：AC自动机由以上两种综合而成；
	
	字符串哈希：
	通过比较哈希值判断字符串是否相等，有极小概率出错；
	选取基底和模数（保证不超范围），则该哈希值为各项字符乘以基底的和除以模数；
	大不了再加个SHA呗，双重保密还能出错？？？；
		例题1：
		使给定的A是若干B连成串的前缀；
		计算子串哈希值，母串补零减已知子串的下一子串哈希值，递推；
		本质是一种映射；
		注意事项：不要映到0去；E大于字符钟数；
		例题2：
		对于给定字符串计算以每个位置为中心最长能扩展多少长度回文串；
		哈希二分，KMP变形；
	
	后缀数组：
	把字符串后缀插入TRIE树，可以计算子串数量，就变成后缀树；
	实际上应该是合并没有分叉节点之后的树；
	首先把所有后缀按照字典序排序，其次哈希（动词）所有后缀。
end.
【问题描述】
对于一个数组A定义F(A) = max abs(a[i] – a[i+1]); 给定一个数组，最多修改其中k个元素，求F(A)的最小值
【输入格式】
第一行两个整数n,k表示数组的元素个数和最多修改的元素个数
第二行n个数表示数组的元素
【输出格式】
一个整数表示F(A)的最小值
【样例输入】
5 2
1 2 1 2 1
【样例输出】
0
【数据范围】
30%的数据保证n<=10 
100%的数据保证 n<=1000 k<=n 0<=ai<=10^9
