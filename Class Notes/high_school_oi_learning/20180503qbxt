#include <c++>
数据结构：
  数据结构本质是逻辑结构；
  单调栈：
  维护栈内元素单调性；
    例题：POJ2559
    首先对于每个下端点维护出可能成为答案的单调栈，其次每次读入之后把对应高度推进栈同时进行维护（可是为什么我一定要手写呢？？？），答案就是当前弹出高度和已有高度的最大值（幸好不用输出方案）；
    代码细节：最后添加一个0作为结束标志；优秀的复杂度O（N）；
  单调队列：
  支持查询序列上不包含的区间的最值 优化动态规划
    例题POJ2823：
    维护一个答案的可能集合，该集合一定满足单调递减，如果新插入的元素递增就更新队列（就是弹出一堆小的元素）；最小值与此相反；（为什么他还是手写，用STL会死星人？？？）
    代码细节：还是别忘了初始化；简单思考一下就和矩形的抽象思路一样了；还是优秀的复杂度（这题马某某讲过）；
  据说可以用它把DP从N^2优化到N；
  二叉堆：
    二叉树：每个节点最多有两个子节点；
    满二叉树：除最后一层外，都有两个节点；
    完全二叉树：缺失部分连续的满二叉树；可以使用一维数组建出此树，且下标连续；
  每个节点带权值，而且父节点与子节点之间存在一定继承关系（大于或小于）；
  操作：插入，在末尾添加并持续更新父节点知道满足堆性质；
  删除，左右交换保证连续性，上下交换保证继承关系；
  STL的priority_queue别忘了用：D；
  优化最短路，堆排序（不停删除取出），
    例题：K路归并
  并查集：
  合并集合，查询两个元素是否在同一集合；用森林表示集合；
  对于后者，用有向边代替无向边，把查询操作变成找父节点的问题；
  对于前者，（走神了）；
    洛谷1525：
    （持续走神）；
  树状数组：
  单点修改，前缀查询；lowbit(x)表示+X&-X；
  可以用来解决逆序对问题；比如火柴排队；
  ST表：
  ST[I][J]表示A[I]到A[I+2^J]的极值；
  （计算过程代码）；
  对于任意区间：找出两个二的幂的区间覆盖指定区间，然后取最大值；可以使用CMATH中LOG2函数；不支持修改；
  二维类似;COGS忠诚；优秀的查询复杂度；
  二叉搜索树||排序二叉树||BST：
  不平衡的树，本质是任意二叉树结构，支持元素插入、查询前驱后继排名；
  线段树||BIT：
  使用完全二叉树节点代表序列的区间；
  要么都在左，要么都在右，要么分成两半，一切围绕此原理制成；
    区间修改：
    LAZY标记的思想，不必每一次修改都立即进行，可以在父节点进行标记，在向下计算时检查标记，符合要求就下放；（代码别忘了）
    COGS1409：
    权值线段树，维护元素出现的次数，可以实现堆（之前的叫区间线段树）；
    SPOJ GSS3：
    长区间的最大子段和，分三种情况；其中跨越中心的情况就是最大后缀加最大前缀，所以同时要维护；
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<queue>
#include<algorithm>
using namespace std;

int n,k;
int a[1000005];

struct dddl
{
    int q[1000005];
    int h,t;
    void clear_()
    {
        h=t=0;
    }
    void push(int x)
    {
        while(h<t &&a[q[t-1]]<=a[x])
            t--;
        q[t++]=x;
    }
    void pop(int x)
    {
        if(h<t &&q[h]==x)
            h++;
    }
    int ans()
    {
        return a[q[h]];
    }
}ddl;

int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);

    for(int i=1;i<=n;i++)
        a[i]=-a[i];
    ddl.clear_();
    for(int i=1;i<=n;i++)
    {
        ddl.push(i);
        if(i>k)
            ddl.pop(i-k);
        if(i>=k)
            printf("%d ",-ddl.ans());
    }
    puts(" ");

    for(int i=1;i<=n;i++)
        a[i]=-a[i];
    ddl.clear_();
    for(int i=1;i<=n;i++)
    {
        ddl.push(i);
        if(i>k)
            ddl.pop(i-k);
        if(i>=k)
            printf("%d ",ddl.ans());
    }
    return 0;
}
