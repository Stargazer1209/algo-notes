#include<C++>
POJ2828:
	用01串进行一个标记，逆序考虑每个操作；
矩形面积并：
	常用扫描线的方法，宽度发生变化时（关键位置）进行更新，扫描线实际长度的变化相当于线段树对应区间的加一，用线段树维护被覆盖的区间；
	把矩形的四角坐标转换成两个事件，然后按照顺序处理；
begin.
动态规划：
数字三角形：
	枚举所有路径，取最大值，但是会有2^N次方；
	记录对于确定X,Y的结果 重复调用时直接返回；
	函数参数一定时，返回值一定，且会被重复调用，就使用记忆化搜索，本质是空间换时间；
	WWW：
		同一阶段其他点标记为负无穷；
边界条件，状态转移方程，转移顺序；
滑雪：
	朴素做法加记忆化；由于转移顺序有约束，所以不适合用递推；
状态是人为定义的，所以设计的状态必须保证没有冗余信息，以及最优子结构和无后效性；
增加维数（更多信息）来达到最优子结构；
传球游戏：
	F[I][J]传I次球在J手里的方法；
LIS：
	最长上升子序列，F[I]表示以I结尾的LIS长度可行，但是F[I]表示前I个元素就不可行；
	可以用树状数组优化；维护可能成为LIS的序列，反复替换，用二分函数寻找合适的更新位置（顺手插入数据结构）；
LCS：
	最长公共子序列，F[I][J]表示A的前I个位置和B的前J个位置LCS长度，A以I结尾B以J结尾的LCS长度；
	都能转移，但是前者复杂度更优；
尼克的任务：
	F[I]表示I分钟到结束的最大空闲时间；
	因为反着定义能寻找后缀，所以进行逆推；
沙子合并：
	哈弗曼树、treap自行了解;
	因为前缀定义状态会导致特殊讨论，所以用区间定义状态；
	F[L][R]L到R堆沙子最小代价;
能量项链：
	环上的区间DP，确定一条没有用到的边并断开，变成序列；
	枚举时存在被重复计算的状态，所以可以记忆化减少枚举的复杂度；
	另一种更好的方法：复制原串，并与后续列举的子串对齐进行枚举，实现更简单；
玩具取名:
	可行性的转移，还是区间DP的逆推；
逆序对数列：
	边构造边输出；
传纸条：
	旋转45度，变成双线程的数字三角形，三维DP解决它：D
背包问题：
	部分背包：
		算是贪心EX吧，任意实数份太赖皮了；
	完全背包：
		变成任意整数份了，不要怕；
		其实就是选不选；辰辰是个好孩子；
	0-1背包：
		越来越简单；
		J从大到小循环；
	多重背包：
		最多拿A[I]个，看成A[I]的单个物品，变成0-1背包；
		每2的N次方打包销售（划分），再跑0-1；
树上的动态规划：
	求最长链：
		无根树转有根树，以子树为阶段DP；
		记F[I]为从第I个点出发，在I的子树里的最长链；
		F[I]=F[J]+1;用DFS的顺序DP；第一种根为答案，第二种情况左右孩子之和为答案；
	没有上司的舞会：
		这题好扯啊~出题人脑洞真大；
		两种情况:选根还是不选根，取最大值；
	练习题：选课；
end.	
