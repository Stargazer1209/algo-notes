图论

邻接矩阵；

邻接表是边表的优化：
{
	按照一个端点排序；
	记录每个点第一次出现的位置；
	存储大图；
}

前向星：
{
	本质上是链表，解决动态加边的问题；
}

最短路：
{
	若有负回路，则为NP问题；
	重构原图，利用性质解决新图（套路）；
	BFS保障了按照边权大小访问，仅限于边权为一，若不是，按照套路：拆点，边权不要太大；
	dijkstra算法，迪克斯特拉：
	{
		要求正权图；
		本质是动态规划（？贪心）；
		知其然知其所以然；
		任意一条最短路包含的所有路径一定是最短路，且长度小于母最短路；
		优化：
			首先由矩阵改为前向星，导致内层第二循环复杂度减小；
			其次用堆优化第一内层循环；
			http://www.matrix67.com/blog/archives/105；
	}
	SPFA：
	{
		同样用于求单源最短路；
		没有负权图的限制，因为它可以多次更新，区别之二；
		堆（优先队列）改成队列，区别之一；
		优化（本质上没有改变复杂度）：
			SLF：若加入元素距离小于队首元素，则加入队首，本质是贪心（建议使用）；
		LLL；随机化：取元素是有一定概率直接移至队尾；
	}
	FLOYD：
	{
		本质是真·动态规划，求任意两点最短路；
		优化：
			空间复杂度，滚动数组；
		优点：
			好写；
			可以求最小环；
	}
}

最小生成树：
{
    环切性质：
		对于图中任意一条不属于MST的边e，对于树上在u,v路径上的任意一条边，必定有w(e)>=w(f)。
	prim算法：
		贪心思想；
		如果用前向星存储图，并用堆优化，就特别好；
	Kruskal算法：
	{
		基于和prim相同的思想；
		并查集维护有根树森林的连通性；
		利用路径压缩优化；
	}
}

DAG;
{
	正常的依赖关系和公平组合游戏的局面转移当中会出现DAG；
	求拓扑序列：
		如果序列中a出现在b前面，那么图中不存在b->a路径；
		算法流程大致如下：
			1. 统计每个点的入度；
			2. 维护一个队列，将所有入度为0的点加入；
			3. 取出队首节点u枚举所有与其相邻的节点v
			4. 令v入度减1，如果变为了0，则加入队列；
			5. 如果队列不为空，返回2；
			6. 出队顺序即为拓扑序列。
	连通性:
		``````
	Tarjan算法:
		
}
