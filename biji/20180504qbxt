#include<C++>
POJ2828:
	用01串进行一个标记，逆序考虑每个操作；
矩形面积并：
	常用扫描线的方法，宽度发生变化时（关键位置）进行更新，扫描线实际长度的变化相当于线段树对应区间的加一，用线段树维护被覆盖的区间；
	把矩形的四角坐标转换成两个事件，然后按照顺序处理；
动态规划：
数字三角形：
	枚举所有路径，取最大值，但是会有2^N次方；
	记录对于确定X,Y的结果 重复调用时直接返回；
	函数参数一定时，返回值一定，且会被重复调用，就使用记忆化搜索，本质是空间换时间；
	WWW：
		同一阶段其他点标记为负无穷；
边界条件，状态转移方程，转移顺序；
滑雪：
	朴素做法加记忆化；由于转移顺序有约束，所以不适合用递推；
状态是人为定义的，所以设计的状态必须保证没有冗余信息，以及最优子结构和无后效性；
增加维数（更多信息）来达到最优子结构；
传球游戏：
	F[I][J]传I次球在J手里的方法；
LIS：
	最长上升子序列，F[I]表示以I结尾的LIS长度可行，但是F[I]表示前I个元素就不可行；
	可以用树状数组优化；维护可能成为LIS的序列，反复替换，用二分函数寻找合适的更新位置（顺手插入数据结构）；
LCS：
	最长公共子序列，F[I][J]表示A的前I个位置和B的前J个位置LCS长度，A以I结尾B以J结尾的LCS长度；
	都能转移，但是前者复杂度更优；
尼克的任务：
	F[I]表示I分钟到结束的最大空闲时间；
	因为反着定义能寻找后缀，所以进行逆推；
沙子合并：
	哈弗曼树、treap;
	因为前缀定义状态会导致特殊讨论，所以用区间定义状态；
	F[L][R]L到R堆沙子最小代价，
