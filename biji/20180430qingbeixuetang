最主要最主要的：二分；

P1181：
{
	贪心的思想：能取就取，多取只会为后面减轻负担。
}

P1182*：
{
	m0为分段数，k0为每一段的值，后者增大，前者减小，因此可以二分查找k的值；
	二分的题目具有单调性；
	整数的二分不存在第三叉，即a[mid]==x，二分查找的返回应该是小于等于给定值的元素；
	左右指针要有一个明确的定义；
}

P1314:
{
	W相当于一个阀门，前者越大，Y越小；
	查找一个W使Y小于等于S，W+1大于S；
	确定与W对应的Y：前缀和干掉；
}

P1083：
{
	差分数组和前缀和数组具有对偶性，可以用来还原原始数组；
	差分数组的变化只存在于首尾端点；
	利用两条性质维护教室数目的差分数组；
}

导数与微分：
{
	导数：某一点图像切线的斜率；
	性质：⑴若Y=C*X/2，则导数*=C，C为常数；
	P2179：
	{
		dE=ki*si*(ui-vi)*du;
		dt=-si/(ui*vi)*du;//ord
		dE=-2ki*ui*ui(ui-vi)*dt;//如果在第i段减小一点点时间，需要多花多少能量
		在i段上少花一点时间，j段上多花时间但减少能量，不断做，直到-2ki*ui*ui(ui-vi)都相同；
		所以二分该系数的值；
		为了确定速度，所以要找到ui的三次函数图像上与   的交点；
	}
	取数：
	{

	}
}

点序列分割：
{
	有意识的抓题目中的关键词；
	从某一个位置t开始试探末端点在哪(如t+64)；
	倍增法：
应用⑴:
	求给定序列中指定长度子序列的最大值，ST表
	{
		for(int =0; i<n; i++)
			st[i][0]=data[i];
		for(int j=0; j<n; j++)
			for(int j=0; j<n; j++)
				{
					st[i][j]=st[i][j-1];
					if(i+base[j-1]<=n)
						st[i][j]=max(st[i+base[j-1][j-1],st[i][j]);
					}
		优点：查询极快；缺点：无法修改，生成慢；
	}

}
