最主要最主要的：二分；

P1181：
{
	贪心的思想：能取就取，多取只会为后面减轻负担。
}

P1182*：
{
	m0为分段数，k0为每一段的值，后者增大，前者减小，因此可以二分查找k的值；
	二分的题目具有单调性；
	整数的二分不存在第三叉，即a[mid]==x，二分查找的返回应该是小于等于给定值的元素；
	左右指针要有一个明确的定义；
}

P1314:
{
	W相当于一个阀门，前者越大，Y越小；
	查找一个W使Y小于等于S，W+1大于S；
	确定与W对应的Y：前缀和干掉；
}

P1083：
{
	差分数组和前缀和数组具有对偶性，可以用来还原原始数组；
	差分数组的变化只存在于首尾端点；
	利用两条性质维护教室数目的差分数组；
}

导数与微分：
{
	导数：某一点图像切线的斜率；
	性质：⑴若Y=C*X/2，则导数*=C，C为常数；
	P2179：
	{
		dE=ki*si*(ui-vi)*du;
		dt=-si/(ui*vi)*du;//ord
		dE=-2ki*ui*ui(ui-vi)*dt;//如果在第i段减小一点点时间，需要多花多少能量
		在i段上少花一点时间，j段上多花时间但减少能量，不断做，直到-2ki*ui*ui(ui-vi)都相同；
		所以二分该系数的值；
		为了确定速度，所以要找到ui的三次函数图像上与   的交点；
	}
	取数：
	{

	}
}

点序列分割：
{
	有意识的抓题目中的关键词；
	从某一个位置t开始试探末端点在哪(如t+64)；
	倍增法：
	应用⑴:
	求给定序列中指定长度子序列的最大值，ST表
	{
		for(int =0; i<n; i++)
			st[i][0]=data[i];
		for(int j=0; j<n; j++)
			for(int j=0; j<n; j++)
				{
					st[i][j]=st[i][j-1];
					if(i+base[j-1]<=n)
						st[i][j]=max(st[i+base[j-1][j-1],st[i][j]);
					}
		优点：查询极快；缺点：无法修改，生成慢；
	}
}

树链通分：
{
	DFS求子树大小，然后每个点的最大儿子之间为重链，其他为轻链；
	D更多应用：
}

COUNT ON TRIGLE:
{
	用一个队列记录修改操作；
	当修改达到一定次数=时，更新大数阵并清空队列；
	技巧：设计有针对性的算法解决有特点的数据；
		  结合两种算法，平衡2部分复杂度可使总复杂度达到最低；
	其他：差分和前缀和；
		  二维前缀和：
		  {
			两种更新方法，看图；
			一种提取方法，看图；
		  }
		  贪心；
		  均摊分析：
		  {
			分析复杂度的手法；
		  }
		  分治：
		  {
			把问题分成相等的两部分；
		  }
		  搜索：
		  {
			实质是图论，如八数码，floodfill；
			记忆化搜索不是DP必要的手段；
		  }
}

额外题2：
{
	求出每个数的质因数，统计出现次数最多的质因数；
	1.筛法2.枚举每个数的质因子3.统计
	核心;选取A[X]，随机法
}

最大独立集：
{
	含义：选取无向图中最多的点，是任意两点不相连；
	本质是NPC问题：没有非多项式解法；
	
	随机化的有趣应用：
	随机一个排列，按照排列顺序选，能选就选；
	O(M)=O(N^2),随机一万次取最优解；
	http://www.matrix67.com/blog/archives/105
}

求出start,end,dist的N个队列中至多只有一个位队伍人数是奇数的队伍：
{
	二分前缀和，找到突变为奇数的位置；
}
