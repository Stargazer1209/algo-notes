#include <c++>
数据结构：
  数据结构本质是逻辑结构；
  单调栈：维护栈内元素单调性；
    例题：POJ2559
    首先对于每个下端点维护出可能成为答案的单调栈，其次每次读入之后把对应高度推进栈同时进行维护（可是为什么我一定要手写呢？？？），答案就是当前弹出高度和已有高度的最大值（幸好不用输出方案）；
    代码细节：最后添加一个0作为结束标志；优秀的复杂度O（N）；
  单调队列：支持查询序列上不包含的区间的最值 优化动态规划
    例题POJ2823：
    维护一个答案的可能集合，该集合一定满足单调递减，如果新插入的元素递增就更新队列（就是弹出一堆小的元素）；最小值与此相反；（为什么他还是手写，用STL会死星人？？？）
    代码细节：还是别忘了初始化；简单思考一下就和矩形的抽象思路一样了；还是优秀的复杂度（这题马某某讲过）；
    据说可以用它把DP从N^2优化到N；
  二叉堆：
    二叉树：每个节点最多有两个子节点；
    满二叉树：除最后一层外，都有两个节点；
    完全二叉树：缺失部分连续的满二叉树；可以使用一维数组建出此树，且下标连续；
  每个节点带权值，而且父节点与子节点之间存在一定继承关系（大于或小于）；
  操作：插入，在末尾添加并持续更新父节点知道满足堆性质；
  删除，左右交换保证连续性，上下交换保证继承关系；
  STL的priority_queue别忘了用：D；
  优化最短路，堆排序（不停删除取出），
    例题：K路归并
  并查集：合并集合，查询两个元素是否在同一集合；用森林表示集合；
  对于后者，用有向边代替无向边，把查询操作变成找父节点的问题；
  对于前者，（走神了）；
    洛谷1525：
    （持续走神）；
  树状数组：
  单点修改，前缀查询；lowbit(x)表示+X&-X；
  
